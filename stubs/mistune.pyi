# Subminimal stubs for mistune==0.8.4
import sys
from typing import Any
from typing import Dict
from typing import List
from typing import Match
from typing import Optional
from typing import Pattern
from typing import Type
from typing import Union

if sys.version_info >= (3, 8):
    from typing import TypedDict
else:
    from typing_extensions import TypedDict

def escape(text: str, quote: bool = ..., smart_amp: bool = ...) -> str: ...
def escape_link(url: str) -> str: ...
def preprocessing(text: str, tab: int = ...) -> str: ...

class BlockGrammar:
    def_links: Pattern[str]
    def_footnotes: Pattern[str]
    newline: Pattern[str]
    block_code: Pattern[str]
    fences: Pattern[str]
    hrule: Pattern[str]
    heading: Pattern[str]
    lheading: Pattern[str]
    block_quote: Pattern[str]
    list_block: Pattern[str]
    list_item: Pattern[str]
    list_bullet: Pattern[str]
    paragraph: Pattern[str]
    block_html: Pattern[str]
    table: Pattern[str]
    nptable: Pattern[str]
    text: Pattern[str]

class Link(TypedDict):
    link: str
    title: Optional[str]

Token = Dict[str, Union[str, int, bool, None]]

class BlockLexer:
    grammar_class: Type[BlockGrammar]
    default_rules: List[str]
    list_rules: List[str]
    footnote_rules: List[str]
    tokens: List[Token]
    def_links: Dict[str, Link]
    def_footnotes: Dict[str, Any]  # values are ignored
    rules: BlockGrammar
    def __init__(self, rules: Optional[BlockGrammar] = ..., **kwargs: Any) -> None: ...
    def __call__(self, text: str, rules: Optional[List[str]] = ...) -> List[Token]: ...
    def parse(self, text: str, rules: Optional[List[str]] = ...) -> List[Token]: ...
    def parse_newline(self, m: Match[str]) -> None: ...
    def parse_block_code(self, m: Match[str]) -> None: ...
    def parse_fences(self, m: Match[str]) -> None: ...
    def parse_heading(self, m: Match[str]) -> None: ...
    def parse_lheading(self, m: Match[str]) -> None: ...
    def parse_hrule(self, m: Match[str]) -> None: ...
    def parse_list_block(self, m: Match[str]) -> None: ...
    def parse_block_quote(self, m: Match[str]) -> None: ...
    def parse_def_links(self, m: Match[str]) -> None: ...
    def parse_def_footnotes(self, m: Match[str]) -> None: ...
    def parse_table(self, m: Match[str]) -> None: ...
    def parse_nptable(self, m: Match[str]) -> None: ...
    def parse_block_html(self, m: Match[str]) -> None: ...
    def parse_paragraph(self, m: Match[str]) -> None: ...
    def parse_text(self, m: Match[str]) -> None: ...

class InlineGrammar:
    escape: Pattern[str]
    inline_html: Pattern[str]
    autolink: Pattern[str]
    link: Pattern[str]
    reflink: Pattern[str]
    nolink: Pattern[str]
    url: Pattern[str]
    double_emphasis: Pattern[str]
    emphasis: Pattern[str]
    code: Pattern[str]
    linebreak: Pattern[str]
    strikethrough: Pattern[str]
    footnote: Pattern[str]
    text: Pattern[str]
    def hard_wrap(self) -> None: ...

class InlineLexer:
    grammar_class: InlineGrammar
    default_rules: List[str]
    inline_html_rules: List[str]
    renderer: "Renderer"
    links: Dict[str, Link]
    footnotes: Dict[str, Any]  # values are ignored
    footnote_index: int
    rules: InlineGrammar
    line_match: Match[str]
    def __init__(
        self,
        renderer: "Renderer",
        rules: Optional[InlineGrammar] = ...,
        **kwargs: Union[bool, Any]
    ) -> None: ...
    def __call__(self, text: str, rules: Optional[List[str]] = ...) -> str: ...
    def setup(
        self, links: Optional[Dict[str, Link]], footnotes: Optional[Dict[str, Any]]
    ) -> None: ...
    def output(self, text: str, rules: Optional[List[str]] = ...) -> str: ...
    def output_escape(self, m: Match[str]) -> str: ...
    def output_autolink(self, m: Match[str]) -> str: ...
    def output_url(self, m: Match[str]) -> str: ...
    def output_inline_html(self, m: Match[str]) -> str: ...
    def output_footnote(self, m: Match[str]) -> str: ...
    def output_link(self, m: Match[str]) -> str: ...
    def output_reflink(self, m: Match[str]) -> str: ...
    def output_nolink(self, m: Match[str]) -> str: ...
    def output_double_emphasis(self, m: Match[str]) -> str: ...
    def output_emphasis(self, m: Match[str]) -> str: ...
    def output_code(self, m: Match[str]) -> str: ...
    def output_linebreak(self, m: Match[str]) -> str: ...
    def output_strikethrough(self, m: Match[str]) -> str: ...
    def output_text(self, m: Match[str]) -> str: ...

class Renderer:
    options: Dict[str, Any]
    def __init__(self, **kwargs: Any) -> None: ...
    def placeholder(self) -> str: ...
    def block_code(self, code: str, lang: Optional[str] = ...) -> str: ...
    def block_quote(self, text: str) -> str: ...
    def block_html(self, html: str) -> str: ...
    def header(self, text: str, level: int, raw: Optional[str] = ...) -> str: ...
    def hrule(self) -> str: ...
    def list(self, body: str, ordered: bool = ...) -> str: ...
    def list_item(self, text: str) -> str: ...
    def paragraph(self, text: str) -> str: ...
    def table(self, header: str, body: str) -> str: ...
    def table_row(self, content: str) -> str: ...
    def table_cell(self, content: str, **flags: Union[bool, Any]) -> str: ...
    def double_emphasis(self, text: str) -> str: ...
    def emphasis(self, text: str) -> str: ...
    def codespan(self, text: str) -> str: ...
    def linebreak(self) -> str: ...
    def strikethrough(self, text: str) -> str: ...
    def text(self, text: str) -> str: ...
    def escape(self, text: str) -> str: ...
    def autolink(self, link: str, is_email: bool = ...) -> str: ...
    def link(self, link: str, title: Optional[str], text: str) -> str: ...
    def image(self, src: str, title: Optional[str], text: str) -> str: ...
    def inline_html(self, html: str) -> str: ...
    def newline(self) -> str: ...
    def footnote_ref(self, key: str, index: int) -> str: ...
    def footnote_item(self, key: str, text: str) -> str: ...
    def footnotes(self, text: str) -> str: ...

class FootnoteItem(TypedDict):
    key: str
    text: str

class Markdown:
    renderer: Renderer
    inline: InlineLexer
    block: BlockLexer
    footnotes: List[FootnoteItem]
    tokens: List[Dict[str, Token]]
    token: Optional[Token]
    def __init__(
        self,
        renderer: Optional[Renderer] = ...,
        inline: Optional[InlineLexer] = ...,
        block: Optional[BlockLexer] = ...,
        **kwargs: Any
    ) -> None: ...
    def __call__(self, text: str) -> str: ...
    def render(self, text: str) -> str: ...
    def parse(self, text: str) -> str: ...
    def pop(self) -> Token: ...
    def peek(self) -> Token: ...
    def output(self, text: str, rules: Optional[List[str]] = ...) -> str: ...
    def tok(self) -> str: ...
    def tok_text(self) -> str: ...
    def output_newline(self) -> str: ...
    def output_hrule(self) -> str: ...
    def output_heading(self) -> str: ...
    def output_code(self) -> str: ...
    def output_table(self) -> str: ...
    def output_block_quote(self) -> str: ...
    def output_list(self) -> str: ...
    def output_list_item(self) -> str: ...
    def output_loose_item(self) -> str: ...
    def output_footnote(self) -> str: ...
    def output_close_html(self) -> str: ...
    def output_open_html(self) -> str: ...
    def output_paragraph(self) -> str: ...
    def output_text(self) -> str: ...

def markdown(text: str, escape: bool = ..., **kwargs: Any) -> None: ...
