import sys
from typing import overload
from typing import Any
from typing import Dict
from typing import Iterator
from typing import Iterable
from typing import List
from typing import MutableMapping
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union
from pathlib import Path
from uuid import UUID

if sys.version_info >= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal

def get_app_dir(app_name: str, roaming: bool = ..., force_posix: bool = ...) -> str: ...

_Token = Union[
    Tuple[Literal["EMPTY"], str, None],
    Tuple[Literal["COMMENT"], str, None],
    Tuple[Literal["SECTION"], str, Tuple[str]],
    Tuple[Literal["KV"], str, Tuple[str, str, str]],
]

class Dialect:
    ns_sep: str
    kv_sep: str
    quotes: Sequence[str]
    true: Sequence[str]
    false: Sequence[str]
    comments: Sequence[str]
    allow_escaping: bool
    linesep: Optional[str]
    def __init__(
        self,
        ns_sep: str = ...,
        kv_sep: str = ...,
        quotes: Sequence[str] = ...,
        true: Sequence[str] = ...,
        false: Sequence[str] = ...,
        comments: Sequence[str] = ...,
        allow_escaping: bool = ...,
        linesep: Optional[str] = ...,
    ) -> None: ...

class IniData(MutableMapping[str, str]):
    def __init__(
        self, mapping: Optional[Dict[str, str]] = ..., dialect: Optional[Dialect] = ...
    ) -> None: ...
    @property
    def is_dirty(self) -> bool: ...
    def get_updated_lines(
        self, line_iter: Optional[Iterable[str]] = ...
    ) -> List[_Token]: ...
    def discard(self) -> None: ...
    def rollover(self) -> None: ...
    def to_dict(self) -> Dict[str, str]: ...
    def __len__(self) -> int: ...
    @overload
    def get(self, name: str) -> Optional[str]: ...
    @overload
    def get(self, name: str, default: Union[Any, str]) -> Union[Any, str]: ...
    def get_ascii(
        self, name: str, default: Optional[bytes] = ...
    ) -> Optional[bytes]: ...
    def get_bool(self, name: str, default: bool = ...) -> bool: ...
    def get_int(self, name: str, default: Optional[int] = ...) -> Optional[int]: ...
    def get_float(
        self, name: str, default: Optional[float] = ...
    ) -> Optional[float]: ...
    def get_uuid(self, name: str, default: Optional[UUID] = ...) -> Optional[UUID]: ...
    def itersections(self) -> Iterator[str]: ...
    def sections(self) -> Iterator[str]: ...
    def iteritems(self) -> Iterator[Tuple[str, str]]: ...
    def iterkeys(self) -> Iterator[str]: ...
    def itervalues(self) -> Iterator[str]: ...
    # keys, items, values current return an iterator, which is incompatible
    # the views returned by Mappings
    def items(self) -> Iterator[Tuple[str, str]]: ...  # type: ignore[override]
    def keys(self) -> Iterator[str]: ...  # type: ignore[override]
    def __iter__(self) -> Iterator[str]: ...
    def values(self) -> Iterator[str]: ...  # type: ignore[override]
    def section_as_dict(self, section: str) -> Dict[str, str]: ...
    def __getitem__(self, name: str) -> str: ...
    def __setitem__(self, name: str, value: str) -> None: ...
    def __delitem__(self, name: str) -> None: ...

class IniFile(IniData):
    def __init__(
        self,
        filename: Union[str, Path],
        encoding: Optional[str] = ...,
        dialect: Optional[Dialect] = ...,
    ) -> None: ...
    def save(self, create_folder: bool = ...) -> None: ...

class AppIniFile(IniFile):
    def __init__(
        self,
        app_name: str,
        filename: Union[str, Path],
        roaming: bool = ...,
        force_posix: bool = ...,
        encoding: Optional[str] = ...,
        dialect: Optional[Dialect] = ...,
    ) -> None: ...
    def save(self, create_folder: bool = ...) -> None: ...
